C51 COMPILER V9.59.0.0   TIMER                                                             02/08/2021 11:23:43 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN timer.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE timer.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*---------------------------------------------------------------------*/
   2          /* --- STC MCU Limited ------------------------------------------------*/
   3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
   4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
   5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
   6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
   7          /* --- Web: www.STCMCU.com --------------------------------------------*/
   8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
   9          /* --- QQ:  800003751 -------------------------------------------------*/
  10          /* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序        */
  11          /*---------------------------------------------------------------------*/
  12          
  13          /*************  功能说明    **************
  14          
  15          本例程基于STC8H8K64U为主控芯片的实验箱8进行编写测试，STC8G、STC8H系列芯片可通用参考.
  16          
  17          本程序演示5个定时器的使用, 本例程均使用16位自动重装.
  18          
  19          下载时, 选择时钟 24MHZ (用户可自行修改频率).
  20          
  21          定时器0做16位自动重装, 中断频率为1000HZ，中断函数从P6.7取反输出500HZ方波信号.
  22          
  23          定时器1做16位自动重装, 中断频率为2000HZ，中断函数从P6.6取反输出1000HZ方波信号.
  24          
  25          定时器2做16位自动重装, 中断频率为3000HZ，中断函数从P6.5取反输出1500HZ方波信号.
  26          
  27          定时器3做16位自动重装, 中断频率为4000HZ，中断函数从P6.4取反输出2000HZ方波信号.
  28          
  29          定时器4做16位自动重装, 中断频率为5000HZ，中断函数从P6.3取反输出2500HZ方波信号.
  30          
  31          ******************************************/
  32          
  33          #include "reg51.h"       //包含此头文件后，里面声明的寄存器不需要再手动输入，避免重复定义
  34          
  35          #define     MAIN_Fosc       24000000UL  //定义主时钟
  36          
  37          
  38          typedef     unsigned char   u8;
  39          typedef     unsigned int    u16;
  40          typedef     unsigned long   u32;
  41          
  42          //手动输入声明"reg51.h"头文件里面没有定义的寄存器
  43          sfr INT_CLKO = 0x8F;
  44          sfr AUXR = 0x8E;
  45          sfr IE2   = 0xAF;   //STC8H8K64U系列
  46          sfr T2H  = 0xD6;
  47          sfr T2L  = 0xD7;
  48          
  49          sfr T4T3M  = 0xD1;
  50          sfr T4H = 0xD2;
  51          sfr T4L = 0xD3;
  52          sfr T3H = 0xD4;
  53          sfr T3L = 0xD5;
  54          
  55          sfr P4   = 0xC0;
C51 COMPILER V9.59.0.0   TIMER                                                             02/08/2021 11:23:43 PAGE 2   

  56          sfr P5   = 0xC8;
  57          sfr P6   = 0xE8;
  58          sfr P7   = 0xF8;
  59          sfr P1M1 = 0x91;    //PxM1.n,PxM0.n     =00--->Standard,    01--->push-pull
  60          sfr P1M0 = 0x92;    //                  =10--->pure input,  11--->open drain
  61          sfr P0M1 = 0x93;
  62          sfr P0M0 = 0x94;
  63          sfr P2M1 = 0x95;
  64          sfr P2M0 = 0x96;
  65          sfr P3M1 = 0xB1;
  66          sfr P3M0 = 0xB2;
  67          sfr P4M1 = 0xB3;
  68          sfr P4M0 = 0xB4;
  69          sfr P5M1 = 0xC9;
  70          sfr P5M0 = 0xCA;
  71          sfr P6M1 = 0xCB;
  72          sfr P6M0 = 0xCC;
  73          sfr P7M1 = 0xE1;
  74          sfr P7M0 = 0xE2;
  75          
  76          sbit P00 = P0^0;
  77          sbit P01 = P0^1;
  78          sbit P02 = P0^2;
  79          sbit P03 = P0^3;
  80          sbit P04 = P0^4;
  81          sbit P05 = P0^5;
  82          sbit P06 = P0^6;
  83          sbit P07 = P0^7;
  84          sbit P10 = P1^0;
  85          sbit P11 = P1^1;
  86          sbit P12 = P1^2;
  87          sbit P13 = P1^3;
  88          sbit P14 = P1^4;
  89          sbit P15 = P1^5;
  90          sbit P16 = P1^6;
  91          sbit P17 = P1^7;
  92          sbit P20 = P2^0;
  93          sbit P21 = P2^1;
  94          sbit P22 = P2^2;
  95          sbit P23 = P2^3;
  96          sbit P24 = P2^4;
  97          sbit P25 = P2^5;
  98          sbit P26 = P2^6;
  99          sbit P27 = P2^7;
 100          sbit P30 = P3^0;
 101          sbit P31 = P3^1;
 102          sbit P32 = P3^2;
 103          sbit P33 = P3^3;
 104          sbit P34 = P3^4;
 105          sbit P35 = P3^5;
 106          sbit P36 = P3^6;
 107          sbit P37 = P3^7;
 108          sbit P40 = P4^0;
 109          sbit P41 = P4^1;
 110          sbit P42 = P4^2;
 111          sbit P43 = P4^3;
 112          sbit P44 = P4^4;
 113          sbit P45 = P4^5;
 114          sbit P46 = P4^6;
 115          sbit P47 = P4^7;
 116          sbit P50 = P5^0;
 117          sbit P51 = P5^1;
C51 COMPILER V9.59.0.0   TIMER                                                             02/08/2021 11:23:43 PAGE 3   

 118          sbit P52 = P5^2;
 119          sbit P53 = P5^3;
 120          sbit P54 = P5^4;
 121          sbit P55 = P5^5;
 122          sbit P56 = P5^6;
 123          sbit P57 = P5^7;
 124          sbit P60 = P6^0;
 125          sbit P61 = P6^1;
 126          sbit P62 = P6^2;
 127          sbit P63 = P6^3;
 128          sbit P64 = P6^4;
 129          sbit P65 = P6^5;
 130          sbit P66 = P6^6;
 131          sbit P67 = P6^7;
 132          
 133          #define ET2 0x04
 134          #define ET3 0x20
 135          #define ET4 0x40
 136          
 137          #define Timer0_Reload   (MAIN_Fosc / 1000)      //Timer 0 中断频率, 1000次/秒
 138          #define Timer1_Reload   (MAIN_Fosc / 2000)      //Timer 1 中断频率, 2000次/秒
 139          #define Timer2_Reload   (MAIN_Fosc / 3000)      //Timer 2 中断频率, 3000次/秒
 140          #define Timer3_Reload   (MAIN_Fosc / 4000)      //Timer 3 中断频率, 4000次/秒
 141          #define Timer4_Reload   (MAIN_Fosc / 5000)      //Timer 4 中断频率, 5000次/秒
 142          
 143          void    Timer0_init(void);
 144          void    Timer1_init(void);
 145          void    Timer2_init(void);
 146          void    Timer3_init(void);
 147          void    Timer4_init(void);
 148          
 149          
 150          //========================================================================
 151          // 函数: void main(void)
 152          // 描述: 主函数.
 153          // 参数: none.
 154          // 返回: none.
 155          // 版本: V1.0, 2015-1-12
 156          //========================================================================
 157          void main(void)
 158          {
 159   1          P0M1 = 0;   P0M0 = 0;   //设置为准双向口
 160   1          P1M1 = 0;   P1M0 = 0;   //设置为准双向口
 161   1          P2M1 = 0;   P2M0 = 0;   //设置为准双向口
 162   1          P3M1 = 0;   P3M0 = 0;   //设置为准双向口
 163   1          P4M1 = 0;   P4M0 = 0;   //设置为准双向口
 164   1          P5M1 = 0;   P5M0 = 0;   //设置为准双向口
 165   1          P6M1 = 0;   P6M0 = 0;   //设置为准双向口
 166   1          P7M1 = 0;   P7M0 = 0;   //设置为准双向口
 167   1      
 168   1          EA = 1;     //打开总中断
 169   1          P40 = 0;    //打开LED电源
 170   1          
 171   1          Timer0_init();
 172   1          Timer1_init();
 173   1          Timer2_init();
 174   1          Timer3_init();
 175   1          Timer4_init();
 176   1      
 177   1          while (1)
 178   1          {
 179   2      
C51 COMPILER V9.59.0.0   TIMER                                                             02/08/2021 11:23:43 PAGE 4   

 180   2          }
 181   1      }
 182          
 183          //========================================================================
 184          // 函数: void   Timer0_init(void)
 185          // 描述: timer0初始化函数.
 186          // 参数: none.
 187          // 返回: none.
 188          // 版本: V1.0, 2015-1-12
 189          //========================================================================
 190          void    Timer0_init(void)
 191          {
 192   1              TR0 = 0;    //停止计数
 193   1      
 194   1          #if (Timer0_Reload < 64)    // 如果用户设置值不合适， 则不启动定时器
                      #error "Timer0设置的中断过快!"
              
                  #elif ((Timer0_Reload/12) < 65536UL)    // 如果用户设置值不合适， 则不启动定时器
 198   1              ET0 = 1;    //允许中断
 199   1          //  PT0 = 1;    //高优先级中断
 200   1              TMOD &= ~0x03;
 201   1              TMOD |= 0;  //工作模式, 0: 16位自动重装, 1: 16位定时/计数, 2: 8位自动重装, 3: 16位自动重装, 不可屏
             -蔽中断
 202   1          //  TMOD |=  0x04;  //对外计数或分频
 203   1              TMOD &= ~0x04;  //定时
 204   1          //  INT_CLKO |=  0x01;  //输出时钟
 205   1              INT_CLKO &= ~0x01;  //不输出时钟
 206   1      
 207   1              #if (Timer0_Reload < 65536UL)
 208   1                  AUXR |=  0x80;  //1T mode
 209   1                  TH0 = (u8)((65536UL - Timer0_Reload) / 256);
 210   1                  TL0 = (u8)((65536UL - Timer0_Reload) % 256);
 211   1              #else
                          AUXR &= ~0x80;  //12T mode
                          TH0 = (u8)((65536UL - Timer0_Reload/12) / 256);
                          TL0 = (u8)((65536UL - Timer0_Reload/12) % 256);
                      #endif
 216   1      
 217   1              TR0 = 1;    //开始运行
 218   1      
 219   1          #else
                      #error "Timer0设置的中断过慢!"
                  #endif
 222   1      }
 223          
 224          //========================================================================
 225          // 函数: void   Timer1_init(void)
 226          // 描述: timer1初始化函数.
 227          // 参数: none.
 228          // 返回: none.
 229          // 版本: V1.0, 2015-1-12
 230          //========================================================================
 231          void    Timer1_init(void)
 232          {
 233   1              TR1 = 0;    //停止计数
 234   1      
 235   1          #if (Timer1_Reload < 64)    // 如果用户设置值不合适， 则不启动定时器
                      #error "Timer1设置的中断过快!"
              
                  #elif ((Timer1_Reload/12) < 65536UL)    // 如果用户设置值不合适， 则不启动定时器
 239   1              ET1 = 1;    //允许中断
 240   1          //  PT1 = 1;    //高优先级中断
C51 COMPILER V9.59.0.0   TIMER                                                             02/08/2021 11:23:43 PAGE 5   

 241   1              TMOD &= ~0x30;
 242   1              TMOD |= (0 << 4);   //工作模式, 0: 16位自动重装, 1: 16位定时/计数, 2: 8位自动重装
 243   1          //  TMOD |=  0x40;  //对外计数或分频
 244   1              TMOD &= ~0x40;  //定时
 245   1          //  INT_CLKO |=  0x02;  //输出时钟
 246   1              INT_CLKO &= ~0x02;  //不输出时钟
 247   1      
 248   1              #if (Timer1_Reload < 65536UL)
 249   1                  AUXR |=  0x40;  //1T mode
 250   1                  TH1 = (u8)((65536UL - Timer1_Reload) / 256);
 251   1                  TL1 = (u8)((65536UL - Timer1_Reload) % 256);
 252   1              #else
                          AUXR &= ~0x40;  //12T mode
                          TH1 = (u8)((65536UL - Timer1_Reload/12) / 256);
                          TL1 = (u8)((65536UL - Timer1_Reload/12) % 256);
                      #endif
 257   1      
 258   1              TR1 = 1;    //开始运行
 259   1      
 260   1          #else
                      #error "Timer1设置的中断过慢!"
                  #endif
 263   1      }
 264          
 265          //========================================================================
 266          // 函数: void   Timer2_init(void)
 267          // 描述: timer2初始化函数.
 268          // 参数: none.
 269          // 返回: none.
 270          // 版本: V1.0, 2015-1-12
 271          //========================================================================
 272          void    Timer2_init(void)
 273          {
 274   1              AUXR &= ~0x1c;      //停止计数, 定时模式, 12T模式
 275   1      
 276   1          #if (Timer2_Reload < 64)    // 如果用户设置值不合适， 则不启动定时器
                      #error "Timer2设置的中断过快!"
              
                  #elif ((Timer2_Reload/12) < 65536UL)    // 如果用户设置值不合适， 则不启动定时器
 280   1          //  IE2  &= ~ET2;       //禁止中断
 281   1              IE2  |=  ET2;       //允许中断
 282   1          //  INT_CLKO |=  0x04;  //输出时钟
 283   1              INT_CLKO &= ~0x04;  //不输出时钟
 284   1      
 285   1              #if (Timer2_Reload < 65536UL)
 286   1                  AUXR |=  (1<<2);    //1T mode
 287   1                  T2H = (u8)((65536UL - Timer2_Reload) / 256);
 288   1                  T2L = (u8)((65536UL - Timer2_Reload) % 256);
 289   1              #else
                          T2H = (u8)((65536UL - Timer2_Reload/12) / 256);
                          T2L = (u8)((65536UL - Timer2_Reload/12) % 256);
                      #endif
 293   1      
 294   1                  AUXR |=  (1<<4);    //开始运行
 295   1      
 296   1          #else
                      #error "Timer2设置的中断过慢!"
                  #endif
 299   1      }
 300          
 301          //========================================================================
 302          // 函数: void   Timer3_init(void)
C51 COMPILER V9.59.0.0   TIMER                                                             02/08/2021 11:23:43 PAGE 6   

 303          // 描述: timer3初始化函数.
 304          // 参数: none.
 305          // 返回: none.
 306          // 版本: V1.0, 2015-1-12
 307          //========================================================================
 308          void    Timer3_init(void)
 309          {
 310   1              T4T3M &= ~0x0f;     //停止计数, 定时模式, 12T模式, 不输出时钟
 311   1      
 312   1          #if (Timer3_Reload < 64)    // 如果用户设置值不合适， 则不启动定时器
                      #error "Timer3设置的中断过快!"
              
                  #elif ((Timer3_Reload/12) < 65536UL)    // 如果用户设置值不合适， 则不启动定时器
 316   1          //  IE2  &= ~ET3;       //禁止中断
 317   1              IE2  |=  ET3;       //允许中断
 318   1          //  T4T3M |=  0x01;     //输出时钟
 319   1          //  T4T3M &= ~0x01;     //不输出时钟
 320   1      
 321   1              #if (Timer3_Reload < 65536UL)
 322   1                  T4T3M |=  (1<<1);    //1T mode
 323   1                  T3H = (u8)((65536UL - Timer3_Reload) / 256);
 324   1                  T3L = (u8)((65536UL - Timer3_Reload) % 256);
 325   1              #else
                          T3H = (u8)((65536UL - Timer3_Reload/12) / 256);
                          T3L = (u8)((65536UL - Timer3_Reload/12) % 256);
                      #endif
 329   1      
 330   1                  T4T3M |=  (1<<3);    //开始运行
 331   1      
 332   1          #else
                      #error "Timer3设置的中断过慢!"
                  #endif
 335   1      }
 336          
 337          //========================================================================
 338          // 函数: void   Timer4_init(void)
 339          // 描述: timer4初始化函数.
 340          // 参数: none.
 341          // 返回: none.
 342          // 版本: V1.0, 2015-1-12
 343          //========================================================================
 344          void    Timer4_init(void)
 345          {
 346   1              T4T3M &= ~0xf0;     //停止计数, 定时模式, 12T模式, 不输出时钟
 347   1      
 348   1          #if (Timer4_Reload < 64)    // 如果用户设置值不合适， 则不启动定时器
                      #error "Timer4设置的中断过快!"
              
                  #elif ((Timer4_Reload/12) < 65536UL)    // 如果用户设置值不合适， 则不启动定时器
 352   1          //  IE2  &= ~ET4;       //禁止中断
 353   1              IE2  |=  ET4;       //允许中断
 354   1          //  T4T3M |=  0x10;     //输出时钟
 355   1          //  T4T3M &= ~0x10;     //不输出时钟
 356   1      
 357   1              #if (Timer4_Reload < 65536UL)
 358   1                  T4T3M |=  (1<<5);    //1T mode
 359   1                  T4H = (u8)((65536UL - Timer4_Reload) / 256);
 360   1                  T4L = (u8)((65536UL - Timer4_Reload) % 256);
 361   1              #else
                          T4H = (u8)((65536UL - Timer4_Reload/12) / 256);
                          T4L = (u8)((65536UL - Timer4_Reload/12) % 256);
                      #endif
C51 COMPILER V9.59.0.0   TIMER                                                             02/08/2021 11:23:43 PAGE 7   

 365   1      
 366   1                  T4T3M |=  (1<<7);    //开始运行
 367   1      
 368   1          #else
                      #error "Timer4设置的中断过慢!"
                  #endif
 371   1      }
 372          
 373          //========================================================================
 374          // 函数: void timer0_int (void) interrupt TIMER0_VECTOR
 375          // 描述:  timer0中断函数.
 376          // 参数: none.
 377          // 返回: none.
 378          // 版本: V1.0, 2015-1-12
 379          //========================================================================
 380          void timer0_int (void) interrupt 1
 381          {
 382   1         P67 = ~P67;
 383   1      }
 384          
 385          //========================================================================
 386          // 函数: void timer1_int (void) interrupt TIMER1_VECTOR
 387          // 描述:  timer1中断函数.
 388          // 参数: none.
 389          // 返回: none.
 390          // 版本: V1.0, 2015-1-12
 391          //========================================================================
 392          void timer1_int (void) interrupt 3
 393          {
 394   1         P66 = ~P66;
 395   1      }
 396          
 397          //========================================================================
 398          // 函数: void timer2_int (void) interrupt TIMER2_VECTOR
 399          // 描述:  timer2中断函数.
 400          // 参数: none.
 401          // 返回: none.
 402          // 版本: V1.0, 2015-1-12
 403          //========================================================================
 404          void timer2_int (void) interrupt 12
 405          {
 406   1          P65 = ~P65;
 407   1      }
 408          
 409          //========================================================================
 410          // 函数: void timer3_int (void) interrupt TIMER3_VECTOR
 411          // 描述:  timer3中断函数.
 412          // 参数: none.
 413          // 返回: none.
 414          // 版本: V1.0, 2015-1-12
 415          //========================================================================
 416          void timer3_int(void) interrupt 19
 417          {
 418   1          P64 = ~P64;
 419   1      }
 420          
 421          //========================================================================
 422          // 函数: void timer4_int (void) interrupt TIMER4_VECTOR
 423          // 描述:  timer4中断函数.
 424          // 参数: none.
 425          // 返回: none.
 426          // 版本: V1.0, 2015-1-12
C51 COMPILER V9.59.0.0   TIMER                                                             02/08/2021 11:23:43 PAGE 8   

 427          //========================================================================
 428          void timer4_int(void) interrupt 20
 429          {
 430   1          P63 = ~P63;
 431   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    179    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
