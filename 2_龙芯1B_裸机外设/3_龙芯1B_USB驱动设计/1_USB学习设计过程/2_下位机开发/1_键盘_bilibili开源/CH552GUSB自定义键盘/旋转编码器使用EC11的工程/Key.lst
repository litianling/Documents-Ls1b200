C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN Key.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE USB\Device\Key.C BROWSE DEBUG OBJECTEXTEND PRINT(.\Key.
                    -lst) OBJECT(Key.obj)

line level    source

   1          /********************************** (C) COPYRIGHT *******************************
   2          CH552eÄ£ÄâUSB¶àÃ½Ìå¼üÅÌ,Ðý×ª±àÂëÆ÷Îª  EC11
   3          2020/4/9 
   4          HID±¨¸æÃèÊö·û²Î¿¼ÎÄÕÂ£ºhttps://www.cnblogs.com/AlwaysOnLines/p/4552840.html
   5          ²Î¿¼Êé¼®£ºÈ¦È¦½ÌÄãÍæUSB£¬HIDÓÃÍ¾±í1.12£¬HID1.11Ð­Òé
   6          ÒÔÏÂºÜ¶à¶¼ÊÇ¸´ÖÆ´óÀÐµÄ³ÌÐò£¬¼ÓÁËÐ©×Ô¼ºµÄÀí½â×¢ÊÍ
   7          *******************************************************************************/
   8          
   9          #include "./Public/CH554.H"                                                      
  10          #include "./Public/DEBUG.H"
  11          #include <string.h>
  12          #include <stdio.h>
  13          
  14          
  15          #define THIS_ENDP0_SIZE         DEFAULT_ENDP0_SIZE
  16          #define CapsLockLED 0x02
  17          
  18          UINT8X  Ep0Buffer[8>(THIS_ENDP0_SIZE+2)?8:(THIS_ENDP0_SIZE+2)] _at_ 0x0000;    //¶Ëµã0 OUT&IN»º³åÇø£¬±ØÐëÊ
             -ÇÅ¼µØÖ·
  19          UINT8X  Ep1Buffer[64>(MAX_PACKET_SIZE+2)?64:(MAX_PACKET_SIZE+2)] _at_ 0x000a;  //¶Ëµã1 IN»º³åÇø,±ØÐëÊÇÅ¼µØ
             -Ö·
  20          UINT8X  Ep2Buffer[64<(MAX_PACKET_SIZE+2)?64:(MAX_PACKET_SIZE+2)] _at_ 0x0050;  //¶Ëµã2 IN»º³åÇø,±ØÐëÊÇÅ¼µØ
             -Ö·
  21          UINT8   SetupReq,SetupLen,Ready,Count,FLAG,UsbConfig,LED_VALID;
  22          PUINT8  pDescr;   //USBÅäÖÃ±êÖ¾
  23          USB_SETUP_REQ   SetupReqBuf;  //ÔÝ´æSetup°ü
  24          bit Ep2InKey;
  25          #define UsbSetupBuf     ((PUSB_SETUP_REQ)Ep0Buffer)
  26          #define DEBUG 0
  27          #pragma  NOAREGS
  28           //¶¨ÒåµÄ4¸ö°´¼üÒÔ¼°EC11µÄA¡¢B½Å
  29          sbit key1=P1^4;
  30          sbit key2=P1^5;
  31          sbit key3=P1^6;
  32          sbit key4=P1^7;
  33          sbit EC11_A = P3^1; 
  34          sbit EC11_B = P3^0;
  35          
  36          UINT8 EC11_A_State = 0;
  37          UINT8 EC11_A_PState = 0;
  38          UINT8 T0RH = 0; //T0¸ß8Î»ÖØÔØÖµ
  39          UINT8 T0RL = 0; //T0µÍ8Î»ÖØÔØÖµ
  40          UINT8 KeyState[6] = {1,1,1,1,1,1}; //°´¼ü×´Ì¬
  41          UINT8 BackState[6] = {1,1,1,1,1,1}; //°´¼üÉÏÒ»´ÎµÄ×´Ì¬
  42          unsigned long pdata TimeThr[4] = {1000, 1000, 1000, 1000};
  43          unsigned long pdata KeyDownTime[4]= {0, 0, 0, 0};
  44          UINT8C key_code_map[6] = {
  45                  0x31,0x32,0x33,0x34,0x35,0x36         //°´¼ü1,°´¼ü2,°´¼ü3,°´¼ü4,°´¼ü5,°´¼ü6
  46          };
  47          /*ÆÕÍ¨¼üÅÌÊý¾Ý*/
  48          UINT8 HIDKey[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  49          /*¶àÃ½Ìå°´¼üÊý¾Ý*/
  50          UINT8 HIDKeyMUL[4] = {0x00,0x00,0x00,0x00};
  51          
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 2   

  52          /****×Ö·û´®ÃèÊö·û****/
  53          /*HIDÀà±¨±íÃèÊö·û*/
  54          UINT8C KeyRepDesc[62] =
  55          {
  56          /******************************************************************
  57          ¼üÅÌ·¢ËÍ¸øPCµÄÊý¾ÝÃ¿´Î8¸ö×Ö½Ú£ºBYTE1 BYTE2 BYTE3 BYTE4 BYTE5 BYTE6 BYTE7 BYTE8¡£¶¨Òå·Ö±ðÊÇ£º
  58          BYTE1 --
  59                 |--bit0:   Left Control 
  60                 |--bit1:   Left Shift 
  61                 |--bit2:   Left Alt 
  62                 |--bit3:   Left GUI 
  63                 |--bit4:   Right Control  
  64                 |--bit5:   Right Shift 
  65                 |--bit6:   Right Alt 
  66                 |--bit7:   Right GUI 
  67          BYTE2 -- ÔÝ²»Çå³þ£¬ÓÐµÄµØ·½ËµÊÇ±£ÁôÎ»
  68          BYTE3--BYTE8 -- ÕâÁù¸öÎªÆÕÍ¨°´¼ü
  69          *******************************************************************/
  70              0x05,0x01,0x09,0x06,0xA1,0x01,0x05,0x07,
  71              0x19,0xe0,0x29,0xe7,0x15,0x00,0x25,0x01,
  72              0x75,0x01,0x95,0x08,0x81,0x02,0x95,0x01,
  73              0x75,0x08,0x81,0x01,0x95,0x03,0x75,0x01,
  74              0x05,0x08,0x19,0x01,0x29,0x03,0x91,0x02,
  75              0x95,0x05,0x75,0x01,0x91,0x01,0x95,0x06,
  76              0x75,0x08,0x26,0xff,0x00,0x05,0x07,0x19,
  77              0x00,0x29,0x91,0x81,0x00,0xC0
  78          };
  79          /*¶àÃ½Ìå¼üÅÌ±¨±íÃèÊö·û*/
  80          UINT8C KeyMULRepDesc[105] =     
  81          {
  82          /**********************************************************************************************
  83          ¼üÅÌ·¢ËÍ¸øPCµÄÊý¾ÝÃ¿´Î4¸ö×Ö½Ú£ºBYTE1 BYTE2 BYTE3 BYTE4
  84          BYTE1 BYTE2 BYTE3 Õâ3¸ö×Ö½Ú·Ö³É24Î»£¬Ã¿¸öÎ»´ú±íÒ»¸ö°´¼ü£¬1´ú±í°´ÏÂ£¬0Ì§Æð¡£
  85          BYTE1 --
  86                 |--bit0:  Vol-  
  87                 |--bit1:  Vol+ 
  88                 |--bit2:  Mute  
  89                 |--bit3:  Email 
  90                 |--bit4:  Media   
  91                 |--bit5:  WWW Home 
  92                 |--bit6:  Play/Pause 
  93                 |--bit7:  Scan Pre Track 
  94          BYTE2 BYTE3°´ÏÂÃæµÄË³ÐòÅÅÏÂÈ¥£¬BYTE3 bit7£º×îºóÒ»¸öUsage( NULL )¡£
  95          BYTE4 --
  96              ÏµÍ³¹¦ÄÜ°´¼ü£¬¹Ø»ú(0x81)£¬ÐÝÃß(0x82£©£¬»½ÐÑ£¨0x83£©
  97          ***********************************************************************************************/
  98                  0x05, 0x0C, //USAGE_PAGE ÓÃÍ¾Ò³Ñ¡Ôñ0x0c(ÓÃ»§Ò³)
  99                  0x09, 0x01, //USAGE ½ÓÏÂÀ´µÄÓ¦ÓÃ¼¯ºÏÓÃÓÚÓÃ»§¿ØÖÆ
 100                  0xA1, 0x01, //COLLECTION ¿ª¼¯ºÏ
 101                          0x15, 0x00, //LOGICAL_MINIMUM (0)
 102                          0x25, 0x01, //LOGICAL_MAXIMUM (1)
 103                          0x0A, 0xEA, 0x00,               /* Usage( Vol- ) */
 104                          0x0A, 0xE9, 0x00,               /* Usage( Vol+ ) */
 105                          0x0A, 0xE2, 0x00,               /* Usage( Mute ) */
 106                          0x0A, 0x8A, 0x01,               /* Usage( Email ) */
 107                          0x0A, 0x83, 0x01,               /* Usage( Media ) */
 108                          0x0A, 0x23, 0x02,               /* Usage( WWW Home ) */
 109                          0x0A, 0xCD, 0x00,               /* Usage( Play/Pause ) */
 110                          0x0A, 0xB6, 0x00,               /* Usage( Scan Pre Track ) */
 111                          0x0A, 0xB5, 0x00,               /* Usage( Scan Next Track ) */
 112                          0x0A, 0xB7, 0x00,               /* Usage( Stop ) */
 113                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 3   

 114                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 115                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 116                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 117                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 118                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 119                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 120                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 121                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 122                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 123                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 124                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 125                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 126                          0x0A, 0x11, 0x22,               /* Usage( NULL ) */
 127                          0x75, 0x01, //REPORT_SIZE (1)
 128                          0x95, 0x18, //REPORT_COUNT (24)
 129                          0x81, 0x02, //INPUT (Data,Var,Abs)ÊäÈë24bitÊý¾Ý
 130                          0x05, 0x01, //USAGE_PAGE ÓÃÍ¾Ò³0x01(ÆÕÍ¨×ÀÃæ)
 131                                  0x19, 0x00, //USAGE_MINIMUM ÓÃÍ¾×îÐ¡Öµ0x00(Î´¶¨Òå)
 132                                  0x29, 0x83, //USAGE_MAXIMUM ÓÃÍ¾×î´óÖµ0x83(ÏµÍ³»½ÐÑ)
 133                                  0x15, 0x00, //LOGICAL_MINIMUM (0)
 134                                  0x25, 0x83, //LOGICAL_MAXIMUM (83)
 135                                  0x75, 0x08, //REPORT_SIZE (8)
 136                                  0x95, 0x01, //REPORT_COUNT (1)
 137                                  0x81, 0x00, //INPUT (Data,Ary,Abs)ÊäÈë1×Ö½ÚÊý¾Ý
 138                  0xC0//END_COLLECTION ±ÕºÏ¼¯ºÏ
 139          };
 140          /*Éè±¸ÃèÊö·û*/
 141          UINT8C DevDesc[18] = {
 142             0x12,      //bLength×Ö¶Î¡£Éè±¸ÃèÊö·ûµÄ³¤¶ÈÎª18(0x12)×Ö½Ú
 143             0x01,          //bDescriptorType×Ö¶Î¡£Éè±¸ÃèÊö·ûµÄ±àºÅÎª0x01
 144             0x10,0x01, //bcdUSB×Ö¶Î¡£ÕâÀïÉèÖÃ°æ±¾ÎªUSB1.1£¬¼´0x0110¡£
 145                        //ÓÉÓÚÊÇÐ¡¶Ë½á¹¹£¬ËùÒÔµÍ×Ö½ÚÔÚÏÈ£¬¼´0x10£¬0x01¡£
 146             0x00,          //bDeviceClass×Ö¶Î¡£ÎÒÃÇ²»ÔÚÉè±¸ÃèÊö·ûÖÐ¶¨ÒåÉè±¸Àà£¬
 147                        //¶øÔÚ½Ó¿ÚÃèÊö·ûÖÐ¶¨ÒåÉè±¸Àà£¬ËùÒÔ¸Ã×Ö¶ÎµÄÖµÎª0¡£
 148             0x00,          //bDeviceSubClass×Ö¶Î¡£bDeviceClass×Ö¶ÎÎª0Ê±£¬¸Ã×Ö¶ÎÒ²Îª0¡£
 149             0x00,          //bDeviceProtocol×Ö¶Î¡£bDeviceClass×Ö¶ÎÎª0Ê±£¬¸Ã×Ö¶ÎÒ²Îª0¡£
 150             0x08,          //bMaxPacketSize0×Ö¶Î¡£ µÄ¶Ëµã0´óÐ¡µÄ8×Ö½Ú¡£
 151             0x3d,0x41, //idVender×Ö¶Î,×¢ÒâÐ¡¶ËÄ£Ê½£¬µÍ×Ö½ÚÔÚÏÈ¡£
 152             0x3a,0x55, //idProduct×Ö¶Î ²úÆ·IDºÅ¡£×¢ÒâÐ¡¶ËÄ£Ê½£¬µÍ×Ö½ÚÓ¦¸ÃÔÚÇ°¡£
 153             0x00,0x00, //bcdDevice×Ö¶Î¡£×¢ÒâÐ¡¶ËÄ£Ê½£¬µÍ×Ö½ÚÓ¦¸ÃÔÚÇ°¡£
 154             0x00,          //iManufacturer×Ö¶Î¡£³§ÉÌ×Ö·û´®µÄË÷Òý
 155             0x00,          //iProduct×Ö¶Î¡£²úÆ·×Ö·û´®µÄË÷ÒýÖµ,×¢Òâ×Ö·û´®Ë÷ÒýÖµ²»ÒªÊ¹ÓÃÏàÍ¬µÄÖµ¡£
 156             0x00,          //iSerialNumber×Ö¶Î¡£Éè±¸µÄÐòÁÐºÅ×Ö·û´®Ë÷ÒýÖµ¡£
 157             0x01           //bNumConfigurations×Ö¶Î¡£¸ÃÉè±¸Ëù¾ßÓÐµÄÅäÖÃÊý¡£
 158          };
 159          /*ÅäÖÃÃèÊö·û*/
 160          UINT8C CfgDesc[59] =
 161          {
 162           /*ÅäÖÃÃèÊö·û*/
 163              0x09, //bLength×Ö¶Î¡£ÅäÖÃÃèÊö·ûµÄ³¤¶ÈÎª9×Ö½Ú
 164                  0x02, //bDescriptorType×Ö¶Î¡£ÅäÖÃÃèÊö·û±àºÅÎª0x02
 165                  0x3b, //wTotalLength×Ö¶Î¡£ÅäÖÃÃèÊö·û¼¯ºÏµÄ×Ü³¤¶È0x003b£¬°üÀ¨ÅäÖÃÃèÊö·û±¾Éí¡¢½Ó¿ÚÃèÊö·û¡¢ÀàÃèÊö·û¡¢¶ËµãÃèÊ
             -ö·ûµÈ£¬LSB
 166                  0x00, 
 167                  0x02, //bNumInterfaces×Ö¶Î¡£¸ÃÅäÖÃ°üº¬µÄ½Ó¿ÚÊý£¬Ö»ÓÐ2¸ö½Ó¿Ú
 168                  0x01, //bConfiguration×Ö¶Î¡£¸ÃÅäÖÃµÄÖµÎª1
 169                  0x01, //iConfigurationz×Ö¶Î£¬¸ÃÅäÖÃµÄ×Ö·û´®Ë÷Òý¡£
 170                  0xA0, //bmAttributes×Ö¶Î,bit4-bit7ÃèÊöÉè±¸µÄÌØÐÔ
 171                  0x64, //bMaxPower×Ö¶Î£¬¸ÃÉè±¸ÐèÒªµÄ×î´óµçÁ÷Á¿¡£Ã¿µ¥Î»µçÁ÷Îª 2 mA    
 172           /*½Ó¿ÚÃèÊö·û*/
 173              //½Ó¿Ú1£¬ÆÕÍ¨¼üÅÌ
 174              0x09,0x04,0x00,0x00,0x01,0x03,0x01,0x01,0x00, //½Ó¿ÚÃèÊö·û,¼üÅÌ  HIDÉè±¸µÄ¶¨Òå·ÅÖÃÔÚ½Ó¿ÚÃèÊö·ûÖÐ
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 4   

 175              0x09,0x21,0x11,0x01,0x00,0x01,0x22,0x3e,0x00, //HIDÀàÃèÊö·û
 176              0x07,0x05,0x81,0x03,0x08,0x00,0x0a, //¶ËµãÃèÊö·û
 177                  //½Ó¿Ú2£¬¶àÃ½Ìå°´¼ü
 178                  0x09,0x04,0x01,0x00,0x01,0x03,0x00,0x00,0x00, // ½Ó¿ÚÃèÊö·û
 179                  0x09,0x21,0x00,0x01,0x00,0x01,0x22,0x69,0x00, // HIDÀàÃèÊö·û
 180                  0x07,0x05,0x82,0x03,0x04,0x00,0x0a,     // ¶ËµãÃèÊö·û 
 181          };
 182          /*******************************************************************************
 183          * Function Name  : USBDeviceInit()
 184          * Description    : USBÉè±¸Ä£Ê½ÅäÖÃ,Éè±¸Ä£Ê½Æô¶¯£¬ÊÕ·¢¶ËµãÅäÖÃ£¬ÖÐ¶Ï¿ªÆô
 185          * Input          : None
 186          * Output         : None
 187          * Return         : None
 188          *******************************************************************************/
 189          void USBDeviceInit()
 190          {
 191   1                IE_USB = 0;
 192   1                USB_CTRL = 0x00; //ÏÈÉè¶¨USBÉè±¸Ä£Ê½
 193   1          UEP0_DMA = Ep0Buffer; //¶Ëµã0Êý¾Ý´«ÊäµØÖ·
 194   1          UEP1_DMA = Ep1Buffer; //¶Ëµã1Êý¾Ý´«ÊäµØÖ·
 195   1              UEP2_DMA = Ep2Buffer; //¶Ëµã2Êý¾Ý´«ÊäµØÖ·
 196   1          UEP4_1_MOD = ~(bUEP4_RX_EN | bUEP4_TX_EN |bUEP1_RX_EN | bUEP1_BUF_MOD) | bUEP4_TX_EN;//¶Ëµã1µ¥64×Ö½ÚÊÕ
             -·¢»º³åÇø,¶Ëµã0ÊÕ·¢
 197   1              UEP2_3_MOD = UEP2_3_MOD & ~bUEP2_BUF_MOD | bUEP2_TX_EN;
 198   1          UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK; //OUTÊÂÎñ·µ»ØACK£¬INÊÂÎñ·µ»ØNAK
 199   1          UEP1_CTRL = bUEP_T_TOG | UEP_T_RES_NAK;     //¶Ëµã1ÊÖ¶¯·­×ªÍ¬²½±êÖ¾Î»£¬INÊÂÎñ·µ»ØNAK
 200   1              UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK; //¶Ëµã2×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬INÊÂÎñ·µ»ØNAK
 201   1                      
 202   1                USB_DEV_AD = 0x00;
 203   1                UDEV_CTRL = bUD_PD_DIS; // ½ûÖ¹DP/DMÏÂÀ­µç×è
 204   1                USB_CTRL = bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN; //Æô¶¯USBÉè±¸¼°DMA£¬ÔÚÖÐ¶ÏÆÚ¼äÖÐ¶Ï±êÖ¾Î´Çå³ýÇ°×Ô¶
             -¯·µ»ØNAK
 205   1                UDEV_CTRL |= bUD_PORT_EN; // ÔÊÐíUSB¶Ë¿Ú
 206   1                USB_INT_FG = 0xFF; // ÇåÖÐ¶Ï±êÖ¾
 207   1                USB_INT_EN = bUIE_SUSPEND | bUIE_TRANSFER | bUIE_BUS_RST;
 208   1                IE_USB = 1;
 209   1      }
 210          /*******************************************************************************
 211          * Function Name  : Enp1IntIn()
 212          * Description    : USBÉè±¸Ä£Ê½¶Ëµã1µÄÖÐ¶ÏÉÏ´«
 213          * Input          : None
 214          * Output         : None
 215          * Return         : None
 216          *******************************************************************************/
 217          void Enp1IntIn( )
 218          {
 219   1          memcpy( Ep1Buffer, HIDKey, sizeof(HIDKey)); //¼ÓÔØÉÏ´«Êý¾Ý
 220   1          UEP1_T_LEN = sizeof(HIDKey); //ÉÏ´«Êý¾Ý³¤¶È
 221   1          UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK; //ÓÐÊý¾ÝÊ±ÉÏ´«Êý¾Ý²¢Ó¦´ðACK
 222   1      }
 223          /*******************************************************************************
 224          * Function Name  : Enp2IntIn()
 225          * Description    : USBÉè±¸Ä£Ê½¶Ëµã2µÄÖÐ¶ÏÉÏ´«
 226          * Input          : None
 227          * Output         : None
 228          * Return         : None
 229          *******************************************************************************/
 230          void Enp2IntIn( )
 231          {
 232   1          memcpy( Ep2Buffer, HIDKeyMUL, sizeof(HIDKeyMUL)); //¼ÓÔØÉÏ´«Êý¾Ý
 233   1          UEP2_T_LEN = sizeof(HIDKeyMUL); //ÉÏ´«Êý¾Ý³¤¶È
 234   1          UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK; //ÓÐÊý¾ÝÊ±ÉÏ´«Êý¾Ý²¢Ó¦´ðACK
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 5   

 235   1      }
 236          
 237          /*******************************************************************************
 238          * Function Name  : DeviceInterrupt()
 239          * Description    : CH559USBÖÐ¶Ï´¦Àíº¯Êý
 240          *******************************************************************************/
 241          void    DeviceInterrupt( void ) interrupt INT_NO_USB using 1                      //USBÖÐ¶Ï·þÎñ³ÌÐò,Ê¹ÓÃ¼Ä
             -´æÆ÷×é1
 242          {
 243   1          UINT8 len;
 244   1          if(UIF_TRANSFER)                                                            //USB´«ÊäÍê³É±êÖ¾
 245   1          {
 246   2              switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP))
 247   2              {
 248   3              case UIS_TOKEN_IN | 2:                                                  //endpoint 2# ÖÐ¶Ï¶ËµãÉÏ´«
 249   3                  UEP2_T_LEN = 0;                                                     //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 250   3      //            UEP1_CTRL ^= bUEP_T_TOG;                                          //Èç¹û²»ÉèÖÃ×Ô¶¯·­×ªÔòÐèÒª
             -ÊÖ¶¯·­×ª
 251   3                  UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 252   3                              FLAG = 1;                                                                                                                       /*´«ÊäÍê³É±êÖ¾*/
 253   3                  break;
 254   3              case UIS_TOKEN_IN | 1:                                                  //endpoint 1# ÖÐ¶Ï¶ËµãÉÏ´«
 255   3                  UEP1_T_LEN = 0;                                                     //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 256   3      //            UEP2_CTRL ^= bUEP_T_TOG;                                          //Èç¹û²»ÉèÖÃ×Ô¶¯·­×ªÔòÐèÒª
             -ÊÖ¶¯·­×ª
 257   3                  UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 258   3                  FLAG = 1;                                                           /*´«ÊäÍê³É±êÖ¾*/
 259   3                  break;
 260   3              case UIS_TOKEN_SETUP | 0:                                                //SETUPÊÂÎñ
 261   3                  len = USB_RX_LEN;
 262   3                  if(len == (sizeof(USB_SETUP_REQ)))
 263   3                  {
 264   4                      SetupLen = UsbSetupBuf->wLengthL;
 265   4                      if(UsbSetupBuf->wLengthH || SetupLen > 0x7F )
 266   4                      {
 267   5                          SetupLen = 0x7F;    // ÏÞÖÆ×Ü³¤¶È
 268   5                      }
 269   4                      len = 0;                                                        // Ä¬ÈÏÎª³É¹¦²¢ÇÒÉÏ´«0³¤¶È
 270   4                      SetupReq = UsbSetupBuf->bRequest;                                                               
 271   4                      if ( ( UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK ) != USB_REQ_TYP_STANDARD )/* HIDÀàÃüÁ
             -î */
 272   4                      {
 273   5                                                                              switch( SetupReq ) 
 274   5                                                                              {
 275   6                                                                                      case 0x01://GetReport
 276   6                                                                                                       break;
 277   6                                                                                      case 0x02://GetIdle
 278   6                                                                                                       break; 
 279   6                                                                                      case 0x03://GetProtocol
 280   6                                                                                                       break;                         
 281   6                                                                                      case 0x09://SetReport                                                                           
 282   6                                                                                                       break;
 283   6                                                                                      case 0x0A://SetIdle
 284   6                                                                                                       break; 
 285   6                                                                                      case 0x0B://SetProtocol
 286   6                                                                                                       break;
 287   6                                                                                      default:
 288   6                                                                                                       len = 0xFF;                                                                                                                /*ÃüÁî²»Ö§³Ö*/                                      
 289   6                                                                                                       break;
 290   6                                                                        }     
 291   5                      }
 292   4                      else
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 6   

 293   4                      {//±ê×¼ÇëÇó
 294   5                          switch(SetupReq)                                        //ÇëÇóÂë
 295   5                          {
 296   6                          case USB_GET_DESCRIPTOR:
 297   6                              switch(UsbSetupBuf->wValueH)
 298   6                              {
 299   7                              case 1:                                             //Éè±¸ÃèÊö·û
 300   7                                  pDescr = DevDesc;                               //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª·¢ËÍµÄ»º³å
             -Çø
 301   7                                  len = sizeof(DevDesc);
 302   7                                  break;
 303   7                              case 2:                                             //ÅäÖÃÃèÊö·û
 304   7                                  pDescr = CfgDesc;                               //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª·¢ËÍµÄ»º³å
             -Çø
 305   7                                  len = sizeof(CfgDesc);
 306   7                                  break;
 307   7                              case 0x22:                                          //±¨±íÃèÊö·û
 308   7                                  if(UsbSetupBuf->wIndexL == 0)                   //½Ó¿Ú0±¨±íÃèÊö·û
 309   7                                  {
 310   8                                      pDescr = KeyRepDesc;                        //Êý¾Ý×¼±¸ÉÏ´«
 311   8                                      len = sizeof(KeyRepDesc);                                                               
 312   8                                  }
 313   7                                                              if(UsbSetupBuf->wIndexL == 1)                   //½Ó¿Ú0±¨±íÃèÊö·û
 314   7                                  {
 315   8                                      pDescr = KeyMULRepDesc;                        //Êý¾Ý×¼±¸ÉÏ´«
 316   8                                      len = sizeof(KeyMULRepDesc);
 317   8                                      Ready = 1;                                  //Èç¹ûÓÐ¸ü¶à½Ó¿Ú£¬¸Ã±ê×¼Î»Ó¦¸Ã
             -ÔÚ×îºóÒ»¸ö½Ó¿ÚÅäÖÃÍê³ÉºóÓÐÐ§
 318   8                                      //IE_UART1 = 1;//¿ªÆô´®¿ÚÖÐ¶Ï                                                                                                                   
 319   8                                                                                                                              
 320   8                                  }
 321   7                                  else
 322   7                                  {
 323   8                                      len = 0xff;                                 //±¾³ÌÐòÖ»ÓÐ2¸ö½Ó¿Ú£¬Õâ¾ä»°Õý³
             -£²»¿ÉÄÜÖ´ÐÐ
 324   8                                  }
 325   7                                  break;
 326   7                              default:
 327   7                                  len = 0xff;                                     //²»Ö§³ÖµÄÃüÁî»òÕß³ö´í
 328   7                                  break;
 329   7                              }
 330   6                              if ( SetupLen > len )
 331   6                              {
 332   7                                  SetupLen = len;    //ÏÞÖÆ×Ü³¤¶È
 333   7                              }
 334   6                              len = SetupLen >= 8 ? 8 : SetupLen;                  //±¾´Î´«Êä³¤¶È
 335   6                              memcpy(Ep0Buffer,pDescr,len);                        //¼ÓÔØÉÏ´«Êý¾Ý
 336   6                              SetupLen -= len;
 337   6                              pDescr += len;
 338   6                              break;
 339   6                          case USB_SET_ADDRESS:
 340   6                              SetupLen = UsbSetupBuf->wValueL;                     //ÔÝ´æUSBÉè±¸µØÖ·
 341   6                              break;
 342   6                          case USB_GET_CONFIGURATION:
 343   6                              Ep0Buffer[0] = UsbConfig;
 344   6                              if ( SetupLen >= 1 )
 345   6                              {
 346   7                                  len = 1;
 347   7                              }
 348   6                              break;
 349   6                          case USB_SET_CONFIGURATION:
 350   6                              UsbConfig = UsbSetupBuf->wValueL;
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 7   

 351   6                              break;
 352   6                          case 0x0A:
 353   6                              break;
 354   6                          case USB_CLEAR_FEATURE:                                            //Clear Feature
 355   6                              if ( ( UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK ) == USB_REQ_RECIP_ENDP )// 
             -¶Ëµã
 356   6                              {
 357   7                                  switch( UsbSetupBuf->wIndexL )
 358   7                                  {
 359   8                                  case 0x82:
 360   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 361   8                                      break;
 362   8                                  case 0x81:
 363   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 364   8                                      break;
 365   8                                  case 0x01:
 366   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 367   8                                      break;
 368   8                                  default:
 369   8                                      len = 0xFF;                                            // ²»Ö§³ÖµÄ¶Ëµã
 370   8                                      break;
 371   8                                  }
 372   7                              }
 373   6                              else
 374   6                              {
 375   7                                  len = 0xFF;                                                // ²»ÊÇ¶Ëµã²»Ö§³Ö
 376   7                              }
 377   6                              break;
 378   6                          case USB_SET_FEATURE:                                              /* Set Feature */
 379   6                              if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x00 )             /* ÉèÖÃÉè±¸ */
 380   6                              {
 381   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01
             - )
 382   7                                  {
 383   8                                      if( CfgDesc[ 7 ] & 0x20 )
 384   8                                      {
 385   9                                          /* ÉèÖÃ»½ÐÑÊ¹ÄÜ±êÖ¾ */
 386   9                                      }
 387   8                                      else
 388   8                                      {
 389   9                                          len = 0xFF;                                        /* ²Ù×÷Ê§°Ü */
 390   9                                      }
 391   8                                  }
 392   7                                  else
 393   7                                  {
 394   8                                      len = 0xFF;                                            /* ²Ù×÷Ê§°Ü */
 395   8                                  }
 396   7                              }
 397   6                              else if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x02 )        /* ÉèÖÃ¶Ëµã */
 398   6                              {
 399   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x00
             - )
 400   7                                  {
 401   8                                      switch( ( ( UINT16 )UsbSetupBuf->wIndexH << 8 ) | UsbSetupBuf->wIndexL )
 402   8                                      {
 403   9                                      case 0x82:
 404   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã2 I
             -N STALL */
 405   9                                          break;
 406   9                                      case 0x02:
 407   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã2 O
             -UT Stall */
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 8   

 408   9                                          break;
 409   9                                      case 0x81:
 410   9                                          UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã1 I
             -N STALL */
 411   9                                          break;
 412   9                                      default:
 413   9                                          len = 0xFF;                               //²Ù×÷Ê§°Ü
 414   9                                          break;
 415   9                                      }
 416   8                                  }
 417   7                                  else
 418   7                                  {
 419   8                                      len = 0xFF;                                   //²Ù×÷Ê§°Ü
 420   8                                  }
 421   7                              }
 422   6                              else
 423   6                              {
 424   7                                  len = 0xFF;                                      //²Ù×÷Ê§°Ü
 425   7                              }
 426   6                              break;
 427   6                          case USB_GET_STATUS:
 428   6                              Ep0Buffer[0] = 0x00;
 429   6                              Ep0Buffer[1] = 0x00;
 430   6                              if ( SetupLen >= 2 )
 431   6                              {
 432   7                                  len = 2;
 433   7                              }
 434   6                              else
 435   6                              {
 436   7                                  len = SetupLen;
 437   7                              }
 438   6                              break;
 439   6                          default:
 440   6                              len = 0xff;                                           //²Ù×÷Ê§°Ü
 441   6                              break;
 442   6                          }
 443   5                      }
 444   4                  }
 445   3                  else
 446   3                  {
 447   4                      len = 0xff;                                                   //°ü³¤¶È´íÎó
 448   4                  }
 449   3                  if(len == 0xff)
 450   3                  {
 451   4                      SetupReq = 0xFF;
 452   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;//STALL
 453   4                  }
 454   3                  else if(len <= 8)                                                //ÉÏ´«Êý¾Ý»òÕß×´Ì¬½×¶Î·µ»Ø0³¤
             -¶È°ü
 455   3                  {
 456   4                      UEP0_T_LEN = len;
 457   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1£¬·
             -µ»ØÓ¦´ðACK
 458   4                  }
 459   3                  else
 460   3                  {
 461   4                      UEP0_T_LEN = 0;  //ËäÈ»ÉÐÎ´µ½×´Ì¬½×¶Î£¬µ«ÊÇÌáÇ°Ô¤ÖÃÉÏ´«0³¤¶ÈÊý¾Ý°üÒÔ·ÀÖ÷»úÌáÇ°½øÈë×´Ì¬½×¶Î
 462   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1,·µ
             -»ØÓ¦´ðACK
 463   4                  }
 464   3                  break;
 465   3              case UIS_TOKEN_IN | 0:                                               //endpoint0 IN
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 9   

 466   3                  switch(SetupReq)
 467   3                  {
 468   4                  case USB_GET_DESCRIPTOR:
 469   4                      len = SetupLen >= 8 ? 8 : SetupLen;                          //±¾´Î´«Êä³¤¶È
 470   4                      memcpy( Ep0Buffer, pDescr, len );                            //¼ÓÔØÉÏ´«Êý¾Ý
 471   4                      SetupLen -= len;
 472   4                      pDescr += len;
 473   4                      UEP0_T_LEN = len;
 474   4                      UEP0_CTRL ^= bUEP_T_TOG;                                     //Í¬²½±êÖ¾Î»·­×ª
 475   4                      break;
 476   4                  case USB_SET_ADDRESS:
 477   4                      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 478   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 479   4                      break;
 480   4                  default:
 481   4                      UEP0_T_LEN = 0;                                              //×´Ì¬½×¶ÎÍê³ÉÖÐ¶Ï»òÕßÊÇÇ¿ÖÆÉ
             -Ï´«0³¤¶ÈÊý¾Ý°ü½áÊø¿ØÖÆ´«Êä
 482   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 483   4                      break;
 484   4                  }
 485   3                  break;
 486   3              case UIS_TOKEN_OUT | 0:  // endpoint0 OUT
 487   3                  len = USB_RX_LEN;
 488   3                  if((SetupReq == 0x09)&& (len == 1))
 489   3                  {
 490   4                    LED_VALID = Ep0Buffer[0];                                                 
 491   4                  }
 492   3                  else if((SetupReq == 0x09) && (len == 8)){//SetReport                                                
 493   4                  }                                                   
 494   3                  UEP0_T_LEN = 0;  //ËäÈ»ÉÐÎ´µ½×´Ì¬½×¶Î£¬µ«ÊÇÌáÇ°Ô¤ÖÃÉÏ´«0³¤¶ÈÊý¾Ý°üÒÔ·ÀÖ÷»úÌáÇ°½øÈë×´Ì¬½×¶Î
 495   3                  UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA0,·µ»ØÓ¦´ðACK
 496   3                  break;
 497   3              default:
 498   3                  break;
 499   3              }
 500   2              UIF_TRANSFER = 0;                                                 //Ð´0Çå¿ÕÖÐ¶Ï
 501   2          }
 502   1          if(UIF_BUS_RST)                                                       //Éè±¸Ä£Ê½USB×ÜÏß¸´Î»ÖÐ¶Ï
 503   1          {
 504   2              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 505   2              UEP1_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK;
 506   2              UEP2_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK | UEP_T_RES_NAK;
 507   2              USB_DEV_AD = 0x00;
 508   2              UIF_SUSPEND = 0;
 509   2              UIF_TRANSFER = 0;
 510   2              UIF_BUS_RST = 0;                                                 //ÇåÖÐ¶Ï±êÖ¾
 511   2          }
 512   1          if (UIF_SUSPEND)                                                     //USB×ÜÏß¹ÒÆð/»½ÐÑÍê³É
 513   1          {
 514   2              UIF_SUSPEND = 0;
 515   2          }
 516   1          else {                                                               //ÒâÍâµÄÖÐ¶Ï,²»¿ÉÄÜ·¢ÉúµÄÇé¿ö
 517   2              USB_INT_FG = 0xFF;                                               //ÇåÖÐ¶Ï±êÖ¾
 518   2          }
 519   1      }
 520          /**¼üÅÌHIDÖµÉÏ´«º¯Êý**/
 521          void HIDValueHandle1()
 522          {
 523   1          TR0 = 0; //·¢ËÍÇ°¹Ø¶¨Ê±Æ÷ÖÐ¶Ï
 524   1              FLAG = 0; //Çå¿ÕUSBÖÐ¶Ï´«ÊäÍê³É±êÖ¾£¬×¼±¸·¢ËÍ°´¼ü°´ÏÂÊý¾Ý
 525   1              Enp1IntIn(); //USBÉè±¸Ä£Ê½¶Ëµã1µÄÖÐ¶ÏÉÏ´«
 526   1              while(FLAG == 0); //µÈ´ýUSBÖÐ¶ÏÊý¾Ý´«ÊäÍê³É
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 10  

 527   1              FLAG = 0; //Çå¿ÕUSBÖÐ¶Ï´«ÊäÍê³É±êÖ¾£¬×¼±¸·¢ËÍ°´¼üÌ§ÆðÊý¾Ý       
 528   1              memset(&HIDKey[0],0,8); //°ÑHIDkeyÖÃ0£¬·¢ËÍ0±íÊ¾°´¼üÌ§Æð
 529   1              Enp1IntIn(); //USBÉè±¸Ä£Ê½¶Ëµã1µÄÖÐ¶ÏÉÏ´«               
 530   1              while(FLAG == 0); //µÈ´ýUSBÖÐ¶ÏÊý¾Ý´«ÊäÍê³É
 531   1              TR0 = 1; //·¢ËÍÍê´ò¿ª¶¨Ê±Æ÷ÖÐ¶Ï         
 532   1      }
 533          /**¶àÃ½Ìå°´¼üHIDÖµÉÏ´«º¯Êý**/
 534          void HIDValueHandle2()
 535          {
 536   1          TR0 = 0; //·¢ËÍÇ°¹Ø¶¨Ê±Æ÷ÖÐ¶Ï
 537   1              FLAG = 0; //Çå¿ÕUSBÖÐ¶Ï´«ÊäÍê³É±êÖ¾£¬×¼±¸·¢ËÍ°´¼ü°´ÏÂÊý¾Ý
 538   1              Enp2IntIn(); //USBÉè±¸Ä£Ê½¶Ëµã2µÄÖÐ¶ÏÉÏ´«
 539   1              while(FLAG == 0); //µÈ´ýUSBÖÐ¶ÏÊý¾Ý´«ÊäÍê³É
 540   1              FLAG = 0; //Çå¿ÕUSBÖÐ¶Ï´«ÊäÍê³É±êÖ¾£¬×¼±¸·¢ËÍ°´¼üÌ§ÆðÊý¾Ý       
 541   1              memset(&HIDKeyMUL[0],0,4); //°ÑHIDKeyMULÖÃ0£¬·¢ËÍ0±íÊ¾°´¼üÌ§Æð
 542   1              Enp2IntIn(); //USBÉè±¸Ä£Ê½¶Ëµã2µÄÖÐ¶ÏÉÏ´«               
 543   1              while(FLAG == 0); //µÈ´ýUSBÖÐ¶ÏÊý¾Ý´«ÊäÍê³É
 544   1              TR0 = 1; //·¢ËÍÍê´ò¿ª¶¨Ê±Æ÷ÖÐ¶Ï         
 545   1      }
 546          /**°´¼üÐÐÎªº¯Êý**/
 547          /*ÕÒµ½°´¼üµÄHIDÖµ×ÔÓÉ·¢»Ó²¿·Ö*/
 548          /*ÆÕÍ¨°´¼ü
 549            ÀýÈçctrl + c :
 550            HIDKey[0] = 0x01;
 551            HIDKey[2] = 0x06;
 552            if(Ready) //Ã¶¾Ù³É¹¦
 553                  {
 554                      HIDValueHandle1();
 555                  }
 556          */
 557          /* °´¼ü¶¯×÷º¯Êý */
 558          void KeyAction(unsigned char keyCode)
 559          {   
 560   1              if(keyCode == 0x31)//°´¼ü1
 561   1              {
 562   2                  HIDKeyMUL[0] = 0x10;  //´ò¿ªÃ½Ìå²¥·ÅÆ÷
 563   2                      if(Ready) //Ã¶¾Ù³É¹¦
 564   2              {
 565   3                  HIDValueHandle2(); //¶àÃ½Ìå°´¼üHIDÖµÉÏ´«
 566   3              }
 567   2              }
 568   1              if(keyCode == 0x32)//°´¼ü2
 569   1              {
 570   2                      HIDKeyMUL[1] = 0x01;  //ÏÂÒ»Çú
 571   2                      if(Ready) //Ã¶¾Ù³É¹¦
 572   2              {
 573   3                  HIDValueHandle2(); //¶àÃ½Ìå°´¼üHIDÖµÉÏ´«
 574   3              }
 575   2              }
 576   1              if(keyCode == 0x33)     //°´¼ü3 
 577   1              {
 578   2                      HIDKeyMUL[0] = 0x80;  //ÉÏÒ»Çú
 579   2                      if(Ready) //Ã¶¾Ù³É¹¦
 580   2              {
 581   3                  HIDValueHandle2(); //ÆÕÍ¨°´¼üHIDÖµÉÏ´«
 582   3              }
 583   2              }
 584   1              if(keyCode == 0x34)     //°´¼ü4 
 585   1              {
 586   2                      HIDKeyMUL[0] = 0x40; //²¥·Å/ÔÝÍ£
 587   2      
 588   2                      if(Ready) //Ã¶¾Ù³É¹¦
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 11  

 589   2              {
 590   3                  HIDValueHandle2(); //¶àÃ½Ìå°´¼üHIDÖµÉÏ´«
 591   3              }
 592   2              }
 593   1              if(keyCode == 0x35)     //°´¼ü5 
 594   1              {
 595   2                      HIDKeyMUL[0] = 0x02; //ÒôÁ¿+
 596   2      
 597   2                      if(Ready) //Ã¶¾Ù³É¹¦
 598   2              {
 599   3                  HIDValueHandle2(); //¶àÃ½Ìå°´¼üHIDÖµÉÏ´«
 600   3              }
 601   2              }
 602   1              if(keyCode == 0x36)     //°´¼ü6 
 603   1              {
 604   2                      HIDKeyMUL[0] = 0x01; //ÒôÁ¿-
 605   2      
 606   2                      if(Ready) //Ã¶¾Ù³É¹¦
 607   2              {
 608   3                  HIDValueHandle2(); //¶àÃ½Ìå°´¼üHIDÖµÉÏ´«
 609   3              }
 610   2              }
 611   1      }
 612          /**°´¼üÇý¶¯**/
 613          void KeyDrive()
 614          {
 615   1              unsigned char j;
 616   1      
 617   1              for(j=0;j<4;j++)
 618   1              {
 619   2                      if(KeyState[j] != BackState[j])
 620   2                      {
 621   3                      if(BackState[j] != 0)
 622   3                              {
 623   4                                      KeyAction(key_code_map[j]);
 624   4                              }
 625   3                              BackState[j] = KeyState[j]; 
 626   3                      }
 627   2                      if(KeyDownTime[j] > 0)
 628   2                      {
 629   3                              if(KeyDownTime[j] >= TimeThr[j])
 630   3                              {
 631   4                                      KeyAction(key_code_map[j]);
 632   4                                      TimeThr[j] += 100;
 633   4                              } 
 634   3                      }
 635   2                      else
 636   2                      {
 637   3                              TimeThr[j] = 1000;
 638   3                      }               
 639   2              }
 640   1      }
 641          /**EC11Çý¶¯**/
 642          /*Ë³Ê±ÕëÐý×ª°´¼ü5£¬ÄæÊ±ÕëÐý×ª°´¼ü6*/
 643          void EC11Drive()
 644          {
 645   1              EC11_A_State = KeyState[4];     //¶ÁÈ¡EC11_A×´Ì¬
 646   1              if(EC11_A_State != EC11_A_PState)
 647   1              {
 648   2                 if(EC11_A_State == 1) //Ë³Ê±ÕëÐý×ª
 649   2                 {
 650   3                    if(KeyState[5] == 0) //ÅÐ¶ÏEC11_B×´Ì¬
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 12  

 651   3                        {
 652   4                                KeyAction(key_code_map[4]);
 653   4                        }
 654   3                        else
 655   3                        {
 656   4                                KeyAction(key_code_map[5]);
 657   4                        }
 658   3                 }
 659   2                 else //ÄæÊ±ÕëÐý×ª
 660   2                 {
 661   3                        if(KeyState[5]  == 1)//ÅÐ¶ÏEC11_B×´Ì¬
 662   3                        {
 663   4                                KeyAction(key_code_map[4]);
 664   4                        }
 665   3                        else
 666   3                        {
 667   4                                KeyAction(key_code_map[5]);
 668   4                        }
 669   3                 }
 670   2                 EC11_A_PState = EC11_A_State;
 671   2              }
 672   1      }
 673          /**T0ÅäÖÃº¯Êý**/
 674          void ConfigT0(UINT8 ms)
 675          {
 676   1          unsigned long tmp = 0;
 677   1      
 678   1              tmp = 12000000/12;
 679   1              tmp = (tmp * ms)/1000;
 680   1              tmp = 65536 - tmp;
 681   1              tmp = tmp + 1;
 682   1          T0RH = (UINT8)(tmp >> 8);
 683   1              T0RL = (UINT8)tmp;
 684   1      
 685   1              TMOD = ( TMOD & ~( bT0_GATE | bT0_CT | bT0_M1 ) ) | bT0_M0;//* Ä£Ê½1£¬16 Î»¶¨Ê±/¼ÆÊýÆ÷
 686   1              TH0 = T0RH;
 687   1              TL0 = T0RL;
 688   1              TF0 = 0;
 689   1              ET0 = 1;
 690   1              TR0 = 1;
 691   1      }
 692          /*****************Ö÷º¯Êý**********************/
 693          main()
 694          {
 695   1          CfgFsys(); //CH552Ê±ÖÓÑ¡Ôñ12MÅäÖÃ
 696   1          mDelaymS(5); //ÐÞ¸ÄÖ÷ÆµµÈ´ýÄÚ²¿¾§ÕñÎÈ¶¨,±Ø¼Ó        
 697   1              ConfigT0(8); //ÅäÖÃ8ms T0ÖÐ¶Ï
 698   1              USBDeviceInit(); //USBÉè±¸Ä£Ê½³õÊ¼»¯
 699   1          EA = 1; //ÔÊÐíµ¥Æ¬»úÖÐ¶Ï
 700   1          UEP1_T_LEN = 0; //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 701   1              UEP2_T_LEN = 0; //Çå¿Õ¶Ëµã2·¢ËÍ³¤¶È
 702   1          FLAG = 0; //Çå¿ÕUSBÖÐ¶Ï´«ÊäÍê³É±êÖ¾
 703   1          Ready = 0;
 704   1              LED_VALID = 1;   //¸øÒ»¸öÄ¬ÈÏÖµ
 705   1      
 706   1              key1 = 1;
 707   1              key2 = 1;
 708   1              key3 = 1;
 709   1              key4 = 1;
 710   1              EC11_A = 1;
 711   1              EC11_B = 1;
 712   1      
C51 COMPILER V9.00   KEY                                                                   08/13/2021 15:57:29 PAGE 13  

 713   1              while(1)
 714   1              {
 715   2                  KeyDrive(); //°´¼üÇý¶¯
 716   2                      EC11Drive();//EC11Çý¶¯
 717   2              }
 718   1      }
 719          /**°´¼üÉ¨Ãèº¯Êý**/
 720          void KeyScan()
 721          {
 722   1              UINT8 i;
 723   1              static UINT8 keybuffer[6] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
 724   1      
 725   1              keybuffer[0] = (keybuffer[0] <<1) | key1;//°´¼üÉ¨Ãè
 726   1              keybuffer[1] = (keybuffer[1] <<1) | key2;
 727   1              keybuffer[2] = (keybuffer[2] <<1) | key3;
 728   1              keybuffer[3] = (keybuffer[3] <<1) | key4;
 729   1              keybuffer[4] = (keybuffer[4] <<1) | EC11_A;//EC11É¨Ãè
 730   1              keybuffer[5] = (keybuffer[5] <<1) | EC11_B;
 731   1              
 732   1              for(i=0;i<6;i++)
 733   1              {
 734   2                      if((keybuffer[i] & 0x0F) == 0x00)
 735   2                      {
 736   3                              KeyState[i] = 0;
 737   3                              if(i>=3)
 738   3                                  break;
 739   3                              KeyDownTime[i] += 4;  //°´ÏÂµÄ³ÖÐøÊ±¼äÀÛ¼Ó
 740   3                      }
 741   2                      else if((keybuffer[i] & 0x0F) == 0x0F)
 742   2                      {
 743   3                              KeyState[i] = 1;
 744   3                              if(i>=3)
 745   3                                  break;
 746   3                              KeyDownTime[i] = 0;   //°´ÏÂµÄ³ÖÐøÊ±¼äÇåÁã
 747   3                      }
 748   2              } 
 749   1      
 750   1      }
 751          /**T0ÖÐ¶Ïº¯Êý**/
 752          void InterruptTimer0() interrupt INT_NO_TMR0 using 1 
 753          {
 754   1              TH0 = T0RH;
 755   1              TL0 = T0RL;
 756   1      
 757   1              KeyScan(); //°´¼üÉ¨Ãè
 758   1      }
 759          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1731    ----
   CONSTANT SIZE    =    250    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     32    ----
   DATA SIZE        =     52       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
